chat app
-> clients + server

- server has a max nr of clients available
- server runs in a loop and checks for clients


- CLIENT:
-> client takes in a parameter that says the server addr -X-
-> client links the ctrl c signal for exiting
-> client runs a send_thread and a receive_thread

SEND_THREAD: loops, gets input from stdin.
             if input is a certain string, then set a variable
             sends message to server

RECEIVE_THREAD: loops, checks the variable, if its set, then exit
                receives the formatted message from the server. 
                HELPER FUNCTION: messages are formatted like "STAGE.xx.xx.xx". the helper function returns a std::vector of 3 containing these elements
                STAGE can be either "INIT" in order to get setup info from sv, or "REGULAR" for regular msg transmission

                "INIT   .ID.COLOR.xx      .xx"
                "REGULAR.ID.COLOR.USERNAME.MESSAGE"

                the server generates a color code on getting a new connection

                the receiver prints the message and then displays a "You" message


SERVER: clients vector. each client has: ID, NAME, COLOR
    0 threads-> new client. SPAWN THREAD. Thread runs the client on coroutines.

          -> Th0 : main function + loop
          -> Th1 : runs a loop, polls; if can accept, add client to vector, update nr_of_clients(atomic), update max_clients/thread(atomic on t0)
                -> runs the poll with EPOLLIN | EPOLLRDHUP, if this event happens that means the client is diconnected
                -> client disconnect, update nr_of_clients, max_clients/thread
          -> Th2-4: run loop, beginning of loop: check nr of clients, if different from last_nr of clients(last iter)
                -> check nr_of_clients(atomic t0)
                -> see the difference between last_iter and now
                -> split the difference (difference/nr_of_threads): iterate through the clients, if one unowned found: mark it(atomic flag in server struct, owned by t0), owned(local to thread)++; if owned==max_clients/thread: break, also break if iterating done

                -> update owned_clients when iterating. An update means adding it to the poll and to the thread local monitoring structure, and launching a suspending read_coroutine and a suspending write_coroutine
                -> if read_ready, resume coroutine, read message, and send it to a thread safe queue, owned by Th0
                -> Th0 reads the queue, consumes the msg, sets(with mutex) a "message_to_broadcast" shared variable, and updates each thread's "has to broadcast" atomic flag variable (in the custom thread struct)
                -> if write_ready, check the "broadcast" variable, if not set, then set it, and send the broadcast msg to all owned client fds.
                

new constants: MAX_CLIENTS_PER_THREAD
MAX_NR_OF_THREADS
MAX_CLIENTS = MAX_NR_OF_THREADS * MAX_CLIENTS_PER_THREAD

new thread opened when the clients dont fit in existing threads
th0 receives a connect, it assigns it to a worker thread.
th0 has a std::array<std::optional<std::pair<int,jthread_WITH_ID>,MAX_NR_OF_THREADS>;
        ->> the int here is incremented each time a thread is assigned a task
        ->> when a thread is created it is assigned with int last_called = 0

when exiting, a launched worker thread puts on the queue a special message
on special msg detection -> optional .reset();
thread selection alg:
    ->> least recently selected. iterate the array. find the minimum int in the array if the optional has data
    ->> put a message on the queue with the corresponding thread id

->>the worker thread takes the first init message from the client.
->>sets name
->>sends an init message to the client - WITH color and ID
->>receives an init fin message from the client

->> if the client is initialized, EPOLLOUT, no broadcast msg on the queue ->> check client queue in the sv

a thread exits if it has no clients - when launched, a thread gets one client


each client has: ID, FD, NAME, COLOR, needs_broadcast(atomic flag), setup_step(atomic int), setup_done(atomic flag)
setup process: 
1. client creation(t1) - setup_step <= 0; sv sets id, color and fd
2. client sends message (t2-4) - setup_step <=1; msg = "SETUP.NAME";
3. sv sets name, sv sends message(t2-4) - setup_step<=2; msg = "SETUP.NAME.ID.COLOR";
4. client sends message(t2-4) - setup_step<=3; msg = "SETUP.DONE"; sv sets setup_done flag;


epoll:
    -> wait called on t1, checks for epollin on sv_socket,
                        -> epollrdhup on each registered client socket.
                        -> non blocking wait
    -> wait called on t2-4, checks for epollin, epollout on each sv_socket
            -> if the event is on a non setup_done client, do the procedure, if done, do the normal msg transmission

epoll class: add monitored fd, private event_arr, wait function with settings, bool check_event with fd and event parameters

coroutines: not really needed actually
